import numpy as np

"""This script assumes we already have data generated by an NN!"""

def load_data(outputs, labels, probs):
    """Outputs--the output of hhat, from which r should be inferred
       Labels--the binary outcomes associated with the inputs
       Probs--the true, underlying p* corresponding to the samples
       Returns--r, D1 (hhat, y, probs), D2
    """
    n = len(outputs)
    D1 = outputs[:n // 2], labels[:n // 2], probs[:n // 2]
    D2 = outputs[n // 2:], labels[n // 2:], probs[n // 2:]
    return len(outputs[0]), D1, D2


def split_sets(D1_hhat, D1_labels, C, B, r):
    """Split D1 into sets by Linjun's method and get the corresponding intervals"""
    quantiles_B = np.linspace(0, 1, B + 1)
    sets = [D1_hhat, D1_labels]
    set_ranges = np.empty((1, r, 2))
    set_ranges[0, :, 0] = -C
    set_ranges[0, :, 1] = C
    
    for j in range(r):
        new_sets = []
        new_ranges = np.tile(set_ranges, (B, 1, 1))
        for i in range(len(sets)):
            features = sets[i][0][:, j]
            quantiles = [-C] + list(np.quantile(features, quantiles_B[1:-1])) + [C]
            sets_tmp = [[] for i in range(B)]
            sets_tmp_y = [[] for i in range(B)]

            for sample_id in range(len(sets[i][0])):
                for k in range(B):
                    if features[sample_id] >= quantiles[k] and features[sample_id] <= quantiles[k + 1]:
                        sets_tmp[k].append(sets[i][0][sample_id])
                        sets_tmp_y[k].append(sets[i][1][sample_id])
                        break
                    assert(k != B - 1, 'split_sets: features[sample_id] =', features[sample_id])

            for k in range(B):
                new_ranges[k * B**j + i, j] = [quantiles[k], quantiles[k + 1]]
                new_sets.append((np.array(sets_tmp[k]), np.array(sets_tmp_y[k])))

        sets = new_sets
        set_ranges = new_ranges

    set_counts = [len(i[0]) for i in sets]
    return sets, set_counts, set_ranges


def get_set(feature, r, set_ranges):
    """Determine which set a sample is in"""

    for i in range(len(set_ranges)):
        flag = True
        for j in range(len(features[0])):
            if not(features[0][j] >= set_ranges[i][j][0] and features[0][j] <= set_ranges[i][j][1]):
                flag = False
                break
        if flag:
            return i
    print("get_set: The given element", feature, "could not be contained within set_ranges")
    raise ValueError


def get_sets(features, r, set_ranges):
    """Determine which set a sample is in"""
    ret = []
    for k, feature in enumerate(features):
        for i in range(len(set_ranges)):
            flag = True
            for j in range(len(set_ranges[i])):  ###### TODO I BELIEVE THIS IS A BUG FEATURE -> SET_RANGES[I]
                if not(feature[j] >= set_ranges[i][j][0] and feature[j] <= set_ranges[i][j][1]):
                    flag = False
                    break
            if flag:
                ret.append(i)
                break
            if i == len(set_ranges) - 1:
                raise ValueError("get_sets: Couldn't place", feature, "within a set. feature corresponds to", samples[k], " input")
    return ret


def compute_D2(D2_hhats, r, set_ranges):
    D2_counts = np.zeros(B**r)
    D2_weights = np.zeros(B**r)
    s = get_sets(D2_hhats, r, set_ranges)

    for i in range(len(D2_hhats)):
        D2_counts[s[i]] += 1
        D2_weights[s[i]] += y[i]
    return D2_counts, D2_weights


def fhat(feature, r, D2_weights, D2_counts, set_ranges):
    """Construct fhat from D2 samples"""
    set_num = get_set(feature, r, set_ranges)
    weights = D2_weights[set_num]
    counts = D2_counts[set_num]
    return weights / counts


data_dir = "/n/home10/mburhanpurkar/multicalibration/code/resnet/data_hybrids_uniform_even"
outputs = np.load(data_dir + '/hhat_train.npy')
labels = np.load(data_dir + '/y_train.npy')[:, 0]
probs = np.load(data_dir + '/y_train_old.npy')[:, 0]
C = 100
B = 5
r = len(outputs[0])
r, D1, D2 = load_data(outputs, labels, probs)
outputs_test = np.load(data_dir + '/hhat_test.npy')
labels_test = np.load(data_dir + '/y_test.npy')[:, 0]
probs_test = np.load(data_dir + '/y_test_old.npy')[:, 0]
sets, set_counts, set_ranges = split_sets(D1[0], D1[1], C, B, r)
D2_counts, D2_weights = compute_D2(D2[0], r, set_ranges)

# Check that none are empty
for i in range(len(D2_counts)):
    if D2_counts[i] == 0:
        print("D2_counts was 0 at i =", i, "with set_ranges[i]:")
        print(set_ranges[i])
        raise ValueError

n_test = len(outputs_test)
fhat_test = np.empty(n_test)
for i in range(n_test):
    fhat_test[i] = fhat(outputs_test[i], r, D2_weights, D2_counts, set_ranges)
mse_p = np.square(np.subtract(fhat_test, probs_test)).mean()
mse_y = np.square(np.subtract(fhat_test, labels_test)).mean()
print("p* MSE:", mse_p)
print("y  MSE:", mse_y)
 
